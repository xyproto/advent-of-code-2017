# -*- coding: utf-8 -*-

from __future__ import print_function

import commands
import glob
import multiprocessing
import os
import os.path
import subprocess
import sys

INCLUDE_PATH = "../include"
COMMON_PATH = "../common"
TEST_SUFFIX = "_test.cpp"
MAIN_SOURCE = "main.cpp"

test_exes = [os.path.splitext(fn)[0] for fn in glob.glob("*" + TEST_SUFFIX)]

# Custom command line targets
if 'clean' in COMMAND_LINE_TARGETS: # Clean built executables and object files
  # Replace the "clean" argument with "-c", and list all targets
  cmd = [x for x in sys.argv if x != "clean"] + ["-c"] + ["main"] + test_exes
  # Clean
  status, output = commands.getstatusoutput(" ".join(cmd))
  print(os.linesep.join(output.split(os.linesep)[1:-1]))
  sys.exit(status)
elif 'testbuild' in COMMAND_LINE_TARGETS: # Build and run tests
  if not test_exes:
    print("Nothing to build")
    sys.exit(0)
  # Remove the "test" argument, and list all test-executable targets
  cmd = [x for x in sys.argv if x != "testbuild"] + test_exes
  # Build the tests
  status, output = commands.getstatusoutput(" ".join(cmd))
  print(os.linesep.join(output.split(os.linesep)[1:-1]))
  sys.exit(status)
elif 'test' in COMMAND_LINE_TARGETS: # Build and run tests
  if not test_exes:
    print("Nothing to build")
    sys.exit(0)
  # Remove the "test" argument, and list all test-executable targets
  cmd = [x for x in sys.argv if x != "test"] + test_exes
  # Build the tests
  output = subprocess.check_output(cmd)
  print(os.linesep.join(output.split(os.linesep)[1:-1]))
  # Run the tests
  for exe in test_exes:
    status, output = commands.getstatusoutput("./" + exe)
    print(output)
    if status != 0:
      sys.exit(status)
  sys.exit(0)
elif 'run' in COMMAND_LINE_TARGETS: # Build and run main
  # Remove the "run" argument, and add "main"
  cmd = [x for x in sys.argv if x != "run"] + ["main"]
  # Build main
  output = subprocess.check_output(cmd)
  print(os.linesep.join(output.split(os.linesep)[1:-1]))
  # Run main
  status, output = commands.getstatusoutput("./main")
  print(output)
  sys.exit(status)

# Set the number of jobs to the number of CPUs
SetOption('num_jobs', multiprocessing.cpu_count())

# Random build-order, for the possiblity of using the cache better
SetOption('random', 1)

# Compiler and compiler flags
env = Environment(CXX="g++",
                  CXXFLAGS='-std=c++17')

# debug=1
if int(ARGUMENTS.get('debug', 0)):
  env.Append(CXXFLAGS=' -O1 -g')
else:
  env.Append(CXXFLAGS=' -O2')

# opt=1
if int(ARGUMENTS.get('opt', 0)):
  env.Append(CXXFLAGS=' -O3')

# clang=1
if int(ARGUMENTS.get('clang', 0)):
  env.Replace(CXX='clang++')

# Warnings and fail at first error
env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wfatal-errors')

# extra=1, even more warnings
if int(ARGUMENTS.get('extra', 0)):
  env.Append(CXXFLAGS=' -Wextra')

# Find all .cpp files that are not main.cpp and not *_test.cpp
dep_src = [fn for fn in glob.glob("*.cpp") if not fn.endswith(TEST_SUFFIX) and fn != MAIN_SOURCE]

# add path to the include files
env.Append(CPPPATH=INCLUDE_PATH)

# Find all included header files in ../include, then check if there are corresponding .cpp files in ../common and add them to dep_src, if there is a main source file
if glob.glob(MAIN_SOURCE):
  includes = []
  has_new_include = True
  examined = []
  while has_new_include:
    has_new_include = False
    for filename in dep_src + [MAIN_SOURCE] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
      if filename in examined:
        continue
      examined.append(filename)
      if glob.glob(filename):
        #if COMMON_PATH in filename:
        #  print("using " + filename)
        #print("FILENAME", filename)
        new_includes = [line.split("\"")[1] for line in open(filename).read().split("\n")[:-1] if line.strip().startswith("#include \"")]
      else:
        continue
      for new_include in new_includes:
        if new_include not in includes:
          has_new_include = True
          includes.append(new_include)
    for include in includes:
      source_filename = os.path.join(COMMON_PATH, include.rsplit(".", 1)[0] + ".cpp")
      if glob.glob(source_filename):
        if source_filename not in dep_src:
          dep_src.append(source_filename)

# Build main executable
main = env.Program("main", [MAIN_SOURCE] + dep_src)

# Set up non-default targets for all the test executables (based on *_test.cpp)
for exe in test_exes:
  env.Program(exe, [exe + ".cpp"] + dep_src)

# Only main is the default target
Default(main)
